{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A lightweight event framework Introduction \u00b6 Tiny-listener is a lightweight and flexible event framework. Requirements \u00b6 Python 3.6+ Installation \u00b6 $ pip install tiny-listener Why use tiny-listener \u00b6 \u2714 Pure Python. \u2714 Lighting-fast, based on native coroutine. \u2714 100% test coverage. Example \u00b6 Create a file example.py with: from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run it: $ tiny-listener example:app >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol How it works \u00b6 Create your own Listener and listen something(e.g. port, queue ...): from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) Add event handler to your listener: app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run listener with command: $ tiny-listener example:app Tiny-listener will dispatch every event automatically: >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol","title":"Introduction"},{"location":"#introduction","text":"Tiny-listener is a lightweight and flexible event framework.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip install tiny-listener","title":"Installation"},{"location":"#why-use-tiny-listener","text":"\u2714 Pure Python. \u2714 Lighting-fast, based on native coroutine. \u2714 100% test coverage.","title":"Why use tiny-listener"},{"location":"#example","text":"Create a file example.py with: from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run it: $ tiny-listener example:app >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol","title":"Example"},{"location":"#how-it-works","text":"Create your own Listener and listen something(e.g. port, queue ...): from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) Add event handler to your listener: app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run listener with command: $ tiny-listener example:app Tiny-listener will dispatch every event automatically: >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol","title":"How it works"},{"location":"usage-http-web/","text":"Tiny \"Web Framework\" \u00b6 Info httptools is a fast HTTP parser lib. Note This tiny \"web framework\" is just intended to show how tiny-listener works. If your really need a web framework for production environment, using FastAPI / Django / Flask instead. STEP 1, Install Tiny-listener and httptools : $ pip install tiny-listener httptools STEP 2, Create python file http_web.py : from asyncio import StreamReader , StreamWriter , start_server from httptools import HttpRequestParser from tiny_listener import Event , Listener , RouteNotFound PORT = 8000 class Request : def __init__ ( self , data : bytes ): self . url = \"\" self . headers = {} self . parser = HttpRequestParser ( self ) self . parser . feed_data ( data ) @property def method ( self ) -> str : return self . parser . get_method () . upper () . decode () @property def http_version ( self ) -> str : return self . parser . get_http_version () def on_url ( self , url : bytes ): self . url = url . decode () def on_header ( self , name , value ): self . headers [ name ] = value class App ( Listener ): async def handler ( self , reader : StreamReader , writer : StreamWriter ): data = await reader . readuntil ( b \" \\r\\n\\r\\n \" ) if data : req = Request ( data ) try : self . fire ( f \" { req . method } : { req . url } \" , data = { \"writer\" : writer , \"request\" : req } ) except RouteNotFound : writer . write ( b \"HTTP/1.1 404 \\n\\n Page Not Found\" ) writer . close () async def listen ( self ): await start_server ( self . handler , port = PORT ) print ( f \"INFO: HTTP server running on on http://127.0.0.1: { PORT } \" ) app = App () @app . after_event async def response ( event : Event ): writer = event . data [ \"writer\" ] req = event . data [ \"request\" ] writer . write ( f \"HTTP/1.1 200 \\n\\n { event . result } \" . encode ()) writer . close () print ( 'INFO: {} : {} - \" {} {} HTTP/ {} \" 200 OK' . format ( * writer . get_extra_info ( \"peername\" ), req . method , req . url , req . http_version ) ) @app . on_event ( \"GET:/\" ) async def home (): return \"Welcome!\" @app . on_event ( \"GET:/user/ {username} \" ) async def hello ( event : Event ): username = event . params [ \"username\" ] return f \"Hello, { username } !\" STEP 3, Run your app: $ tiny-listener http_web:app $ INFO: Tiny-listener HTTP server running on on localhost:8000 STEP 4, Try this on your browser: http://127.0.0.1:8000/user/Bob ... $ INFO: 127 .0.0.1:52579 - \"GET /user/Bob HTTP/1.1\" 200 OK","title":"Usage: Tiny \"Web Framwork\""},{"location":"usage-http-web/#tiny-web-framework","text":"Info httptools is a fast HTTP parser lib. Note This tiny \"web framework\" is just intended to show how tiny-listener works. If your really need a web framework for production environment, using FastAPI / Django / Flask instead. STEP 1, Install Tiny-listener and httptools : $ pip install tiny-listener httptools STEP 2, Create python file http_web.py : from asyncio import StreamReader , StreamWriter , start_server from httptools import HttpRequestParser from tiny_listener import Event , Listener , RouteNotFound PORT = 8000 class Request : def __init__ ( self , data : bytes ): self . url = \"\" self . headers = {} self . parser = HttpRequestParser ( self ) self . parser . feed_data ( data ) @property def method ( self ) -> str : return self . parser . get_method () . upper () . decode () @property def http_version ( self ) -> str : return self . parser . get_http_version () def on_url ( self , url : bytes ): self . url = url . decode () def on_header ( self , name , value ): self . headers [ name ] = value class App ( Listener ): async def handler ( self , reader : StreamReader , writer : StreamWriter ): data = await reader . readuntil ( b \" \\r\\n\\r\\n \" ) if data : req = Request ( data ) try : self . fire ( f \" { req . method } : { req . url } \" , data = { \"writer\" : writer , \"request\" : req } ) except RouteNotFound : writer . write ( b \"HTTP/1.1 404 \\n\\n Page Not Found\" ) writer . close () async def listen ( self ): await start_server ( self . handler , port = PORT ) print ( f \"INFO: HTTP server running on on http://127.0.0.1: { PORT } \" ) app = App () @app . after_event async def response ( event : Event ): writer = event . data [ \"writer\" ] req = event . data [ \"request\" ] writer . write ( f \"HTTP/1.1 200 \\n\\n { event . result } \" . encode ()) writer . close () print ( 'INFO: {} : {} - \" {} {} HTTP/ {} \" 200 OK' . format ( * writer . get_extra_info ( \"peername\" ), req . method , req . url , req . http_version ) ) @app . on_event ( \"GET:/\" ) async def home (): return \"Welcome!\" @app . on_event ( \"GET:/user/ {username} \" ) async def hello ( event : Event ): username = event . params [ \"username\" ] return f \"Hello, { username } !\" STEP 3, Run your app: $ tiny-listener http_web:app $ INFO: Tiny-listener HTTP server running on on localhost:8000 STEP 4, Try this on your browser: http://127.0.0.1:8000/user/Bob ... $ INFO: 127 .0.0.1:52579 - \"GET /user/Bob HTTP/1.1\" 200 OK","title":"Tiny \"Web Framework\""},{"location":"usage-mqtt-client/","text":"MQTT Client \u00b6 Info MQTT is a lightweight IOT protocol. amqtt is an open source MQTT client and broker implementation with asyncio. Warning Most of time, MQTT client requires an available MQTT server. We use a publicly test MQTT server http://test.mosquitto.org/ here. Please don't publish anything sensitive, anybody could be listening. STEP 1, Install Tiny-listener and amqtt : $ pip install tiny-listener amqtt STEP 2, Create python file mqtt_client.py : from amqtt.client import MQTTClient from amqtt.mqtt.constants import QOS_0 from amqtt.mqtt.publish import PublishPacket from tiny_listener import Event , Listener SERVER_ADDRESS = \"mqtt://test.mosquitto.org\" class App ( Listener ): async def listen ( self ): client = MQTTClient () await client . connect ( SERVER_ADDRESS ) await client . subscribe ( [ ( \"/test/home/+/temperature\" , QOS_0 ), ] ) ctx = self . new_ctx ( scope = { \"client\" : client }) ctx . fire ( \"/send\" ) ctx . fire ( \"/recv\" ) app = App () @app . on_event ( \"/send\" ) async def _ ( event : Event ): client = event . ctx . scope [ \"client\" ] await client . publish ( \"/test/home/living_room/temperature\" , b \"13\" ) await client . publish ( \"/test/home/kitchen/temperature\" , b \"15\" ) @app . on_event ( \"/recv\" ) async def _ ( event : Event ): client = event . ctx . scope [ \"client\" ] while True : message = await client . deliver_message () packet : PublishPacket = message . publish_packet app . fire ( packet . variable_header . topic_name , data = { \"payload\" : packet . payload }) @app . on_event ( \"/test/home/ {room} /temperature\" ) async def _ ( event : Event ): room = event . params [ \"room\" ] temperature = event . data [ \"payload\" ] . data . decode () print ( \"INFO: {:<13} {} \u2103\" . format ( room , temperature )) STEP 3, Run your app: $ tiny-listener mqtt_client:app Check the logs: INFO: living_room 13 \u00b0C INFO: kitchen 15 \u00b0C","title":"Usage: MQTT client"},{"location":"usage-mqtt-client/#mqtt-client","text":"Info MQTT is a lightweight IOT protocol. amqtt is an open source MQTT client and broker implementation with asyncio. Warning Most of time, MQTT client requires an available MQTT server. We use a publicly test MQTT server http://test.mosquitto.org/ here. Please don't publish anything sensitive, anybody could be listening. STEP 1, Install Tiny-listener and amqtt : $ pip install tiny-listener amqtt STEP 2, Create python file mqtt_client.py : from amqtt.client import MQTTClient from amqtt.mqtt.constants import QOS_0 from amqtt.mqtt.publish import PublishPacket from tiny_listener import Event , Listener SERVER_ADDRESS = \"mqtt://test.mosquitto.org\" class App ( Listener ): async def listen ( self ): client = MQTTClient () await client . connect ( SERVER_ADDRESS ) await client . subscribe ( [ ( \"/test/home/+/temperature\" , QOS_0 ), ] ) ctx = self . new_ctx ( scope = { \"client\" : client }) ctx . fire ( \"/send\" ) ctx . fire ( \"/recv\" ) app = App () @app . on_event ( \"/send\" ) async def _ ( event : Event ): client = event . ctx . scope [ \"client\" ] await client . publish ( \"/test/home/living_room/temperature\" , b \"13\" ) await client . publish ( \"/test/home/kitchen/temperature\" , b \"15\" ) @app . on_event ( \"/recv\" ) async def _ ( event : Event ): client = event . ctx . scope [ \"client\" ] while True : message = await client . deliver_message () packet : PublishPacket = message . publish_packet app . fire ( packet . variable_header . topic_name , data = { \"payload\" : packet . payload }) @app . on_event ( \"/test/home/ {room} /temperature\" ) async def _ ( event : Event ): room = event . params [ \"room\" ] temperature = event . data [ \"payload\" ] . data . decode () print ( \"INFO: {:<13} {} \u2103\" . format ( room , temperature )) STEP 3, Run your app: $ tiny-listener mqtt_client:app Check the logs: INFO: living_room 13 \u00b0C INFO: kitchen 15 \u00b0C","title":"MQTT Client"},{"location":"usage-rabbitmq-consumer/","text":"RabbitMQ Consumer \u00b6 Info RabbitMQ is an open source message broker. aio-pika is a wrapper for the aiormq for asyncio and humans. Note This tutorial assumes RabbitMQ is installed and running on localhost on the standard port (5672). See: Downloading and Installing RabbitMQ STEP 1, Install Tiny-listener and aio-pika : $ pip install tiny-listener aio-pika STEP 2, Create python file rabbitmq_consumer.py : import aio_pika from tiny_listener import Event , Listener class App ( Listener ): async def listen ( self ): connection = await aio_pika . connect_robust ( \"amqp://127.0.0.1/\" ) async with connection : channel = await connection . channel () queue = await channel . declare_queue ( \"test_queue\" , auto_delete = True ) app . fire ( \"/produce\" , data = { \"channel\" : channel }) async with queue . iterator () as msg_queue : async for msg in msg_queue : async with msg . process (): app . fire ( f \"/app/ { msg . app_id } /consume\" , data = { \"data\" : msg . body }) app = App () @app . on_event ( \"/produce\" ) async def _ ( event : Event ): channel = event . data [ \"channel\" ] await channel . default_exchange . publish ( aio_pika . Message ( body = b \"Hello, Alice!\" , app_id = \"001\" ), routing_key = \"test_queue\" ) await channel . default_exchange . publish ( aio_pika . Message ( body = b \"Hello, Bob!\" , app_id = \"002\" ), routing_key = \"test_queue\" ) @app . on_event ( \"/app/ {app_id} /consume\" ) async def _ ( event : Event ): app_id = event . params [ \"app_id\" ] data = event . data [ \"data\" ] print ( \"INFO: App[ {} ] consume: {} \" . format ( app_id , data )) STEP 3, Run your app: $ tiny-listener rabbitmq_consumer:app Check the logs: INFO: App[001] consume: b'Hello, Alice!' INFO: App[002] consume: b'Hello, Bob!'","title":"Usage: RabbitMQ consumer"},{"location":"usage-rabbitmq-consumer/#rabbitmq-consumer","text":"Info RabbitMQ is an open source message broker. aio-pika is a wrapper for the aiormq for asyncio and humans. Note This tutorial assumes RabbitMQ is installed and running on localhost on the standard port (5672). See: Downloading and Installing RabbitMQ STEP 1, Install Tiny-listener and aio-pika : $ pip install tiny-listener aio-pika STEP 2, Create python file rabbitmq_consumer.py : import aio_pika from tiny_listener import Event , Listener class App ( Listener ): async def listen ( self ): connection = await aio_pika . connect_robust ( \"amqp://127.0.0.1/\" ) async with connection : channel = await connection . channel () queue = await channel . declare_queue ( \"test_queue\" , auto_delete = True ) app . fire ( \"/produce\" , data = { \"channel\" : channel }) async with queue . iterator () as msg_queue : async for msg in msg_queue : async with msg . process (): app . fire ( f \"/app/ { msg . app_id } /consume\" , data = { \"data\" : msg . body }) app = App () @app . on_event ( \"/produce\" ) async def _ ( event : Event ): channel = event . data [ \"channel\" ] await channel . default_exchange . publish ( aio_pika . Message ( body = b \"Hello, Alice!\" , app_id = \"001\" ), routing_key = \"test_queue\" ) await channel . default_exchange . publish ( aio_pika . Message ( body = b \"Hello, Bob!\" , app_id = \"002\" ), routing_key = \"test_queue\" ) @app . on_event ( \"/app/ {app_id} /consume\" ) async def _ ( event : Event ): app_id = event . params [ \"app_id\" ] data = event . data [ \"data\" ] print ( \"INFO: App[ {} ] consume: {} \" . format ( app_id , data )) STEP 3, Run your app: $ tiny-listener rabbitmq_consumer:app Check the logs: INFO: App[001] consume: b'Hello, Alice!' INFO: App[002] consume: b'Hello, Bob!'","title":"RabbitMQ Consumer"},{"location":"usage-tcp-chat-bot/","text":"TCP Chat Bot \u00b6 STEP 1, Install Tiny-listener: $ pip install tiny-listener STEP 2, Create python file tcp_chat_bot.py : from asyncio import StreamReader , StreamWriter , start_server from tiny_listener import Depends , Event , Listener , RouteNotFound ADDRESS = ( \"127.0.0.1\" , 12345 ) class App ( Listener ): @staticmethod async def tcp_handler ( reader : StreamReader , writer : StreamWriter ): while True : payload = await reader . readline () if not payload : break try : app . fire ( payload . strip () . decode (), data = { \"writer\" : writer }) except RouteNotFound : writer . write ( b \"Huh, go on. \\n \" ) async def listen ( self ): await start_server ( self . tcp_handler , * ADDRESS ) app = App () async def get_writer ( event : Event ): return event . data [ \"writer\" ] @app . on_event ( \" {_} ?\" ) async def _ ( writer : StreamWriter = Depends ( get_writer )): writer . write ( b \"I am confused, may be you should google it. \\n \" ) @app . on_event ( \" {_} .\" ) async def _ ( writer : StreamWriter = Depends ( get_writer )): writer . write ( b \"Yes, it makes sense to me. \\n \" ) STEP 3, Run your app: $ tiny-listener tcp_chat_bot:app STEP 4, Open a new terminal with: $ nc -I 60 localhost 12345 STEP 5, Chat with your bot: $ hello! Huh, go on. $ who are you? I am confused, may be you should google it. $ earth is flat. Yes, it makes sense to me.","title":"Usage: \"Chat Bot\" with TCP"},{"location":"usage-tcp-chat-bot/#tcp-chat-bot","text":"STEP 1, Install Tiny-listener: $ pip install tiny-listener STEP 2, Create python file tcp_chat_bot.py : from asyncio import StreamReader , StreamWriter , start_server from tiny_listener import Depends , Event , Listener , RouteNotFound ADDRESS = ( \"127.0.0.1\" , 12345 ) class App ( Listener ): @staticmethod async def tcp_handler ( reader : StreamReader , writer : StreamWriter ): while True : payload = await reader . readline () if not payload : break try : app . fire ( payload . strip () . decode (), data = { \"writer\" : writer }) except RouteNotFound : writer . write ( b \"Huh, go on. \\n \" ) async def listen ( self ): await start_server ( self . tcp_handler , * ADDRESS ) app = App () async def get_writer ( event : Event ): return event . data [ \"writer\" ] @app . on_event ( \" {_} ?\" ) async def _ ( writer : StreamWriter = Depends ( get_writer )): writer . write ( b \"I am confused, may be you should google it. \\n \" ) @app . on_event ( \" {_} .\" ) async def _ ( writer : StreamWriter = Depends ( get_writer )): writer . write ( b \"Yes, it makes sense to me. \\n \" ) STEP 3, Run your app: $ tiny-listener tcp_chat_bot:app STEP 4, Open a new terminal with: $ nc -I 60 localhost 12345 STEP 5, Chat with your bot: $ hello! Huh, go on. $ who are you? I am confused, may be you should google it. $ earth is flat. Yes, it makes sense to me.","title":"TCP Chat Bot"}]}