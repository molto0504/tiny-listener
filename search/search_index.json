{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"A lightweight event framework"},{"location":"#introduction","title":"Introduction","text":"<p>Tiny-listener is a lightweight and flexible event framework.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install tiny-listener\n</code></pre>"},{"location":"#why-use-tiny-listener","title":"Why use tiny-listener","text":"<ul> <li>\u2714 Pure Python.</li> <li>\u2714 Lightning-fast, based on native coroutine.</li> <li>\u2714 100% test coverage.</li> </ul>"},{"location":"#example","title":"Example","text":"<p>Consider we want to write a program keep listening message received from somewhere (e.g. http request or message queue), when message arrived, we want to execute a series of operations in a certain order, e.g.</p> <ul> <li>step 1: save user data to database</li> <li>step 2: send email to user</li> </ul> <p>In the development process, we often encounter such problems:</p> <ul> <li>the source of step 1 and step 2 may be different</li> <li>step 2 may depend on the result of step 1, that is to say, step 2 may need to wait for step 1 to complete</li> <li>there are many messages, many events, and it is not easy to maintain</li> </ul> <p>Tiny-listener may help you solve these problems:</p> <p>Create a file <code>example.py</code> with:</p> <pre><code>from tiny_listener import Event, Listener, Param\n\n\nclass App(Listener):\n    async def listen(self):\n        ctx = self.new_ctx()\n        ctx.trigger_event(\"step 2: send email to alice@tl.com\")\n        ctx.trigger_event(\"step 1: save Alice's data to database\", data={\"age\": 35})\n\n\napp = App()\n\n\n@app.on_event(\"step 1: save {username}'s data to database\")\nasync def step_1(event: Event, username: Param):\n    age = event.data[\"age\"]\n    print(f\"Step-1: Save data done!, {username=}, {age=}\")\n\n\n@app.on_event(\"step 2: send email to {email}\")\nasync def step_2(event: Event, email: Param):\n    await event.wait_event_done(\"step_1\")\n    print(f\"Step-2: Send email done!, {email=}\")\n</code></pre> <p>Run it:</p> <pre><code>$ tiny-listener example:app\n&gt;&gt;&gt; Save data done!, username='Alice', age=35\n&gt;&gt;&gt; Send email done!, email='alice@tl.com'\n</code></pre>"},{"location":"#how-it-works","title":"How it works","text":"<ul> <li>Create your own Listener and listen something(e.g. port, queue ...):</li> </ul> <pre><code>from tiny_listener import Event, Listener, Param\n\n\nclass App(Listener):\n    async def listen(self):\n        ctx = self.new_ctx()\n        ctx.trigger_event(\"step 2: send email to alice@tl.com\")\n        ctx.trigger_event(\"step 1: save Alice's data to database\", data={\"age\": 35})\n</code></pre> <ul> <li>Add event handler to your listener:</li> </ul> <pre><code>app = App()\n\n\n@app.on_event(\"step 1: save {username}'s data to database\")\nasync def step_1(event: Event, username: Param):\n    age = event.data[\"age\"]\n    print(f\"Step-1: Save data done!, {username=}, {age=}\")\n\n\n@app.on_event(\"step 2: send email to {email}\")\nasync def step_2(event: Event, email: Param):\n    await event.wait_event_done(\"step_1\")\n    print(f\"Step-2: Send email done!, {email=}\")\n</code></pre> <ul> <li>Run listener with command:</li> </ul> <pre><code>$ tiny-listener example:app\n</code></pre> <ul> <li>Tiny-listener will dispatch every event automatically:</li> </ul> <pre><code>&gt;&gt;&gt; Step-1: Save data done!, username='Alice', age=35\n&gt;&gt;&gt; Step-2: Send email done!, email='alice@tl.com'\n</code></pre>"},{"location":"usage-http-web/","title":"Tiny \"Web Framework\"","text":"<p>Info</p> <p>httptools is a fast HTTP parser lib.</p> <p>Note</p> <p>This tiny \"web framework\" is just intended to show how tiny-listener works.</p> <p>If your really need a web framework for production environment, using FastAPI / Django / Flask instead.</p> <p>STEP 1, Install Tiny-listener and httptools:</p> <pre><code>$ pip install tiny-listener httptools </code></pre> <p>STEP 2, Create python file <code>http_web.py</code>:</p> <pre><code>from asyncio import StreamReader, StreamWriter, start_server\n\nfrom httptools import HttpRequestParser\n\nfrom tiny_listener import Event, EventNotFound, Listener, Param\n\nPORT = 8000\n\n\nclass Request:\n    def __init__(self, data: bytes):\n        self.url = \"\"\n        self.headers = {}\n        self.parser = HttpRequestParser(self)\n        self.parser.feed_data(data)\n\n    @property\n    def method(self) -&gt; str:\n        return self.parser.get_method().upper().decode()\n\n    @property\n    def http_version(self) -&gt; str:\n        return self.parser.get_http_version()\n\n    def on_url(self, url: bytes):\n        self.url = url.decode()\n\n    def on_header(self, name, value):\n        self.headers[name] = value\n\n\nclass App(Listener):\n    async def handler(self, reader: StreamReader, writer: StreamWriter):\n        data = await reader.readuntil(b\"\\r\\n\\r\\n\")\n        if data:\n            req = Request(data)\n            try:\n                self.trigger_event(f\"{req.method}:{req.url}\", data={\"writer\": writer, \"request\": req})\n            except EventNotFound:\n                writer.write(b\"HTTP/1.1 404\\n\\nPage Not Found\")\n                writer.close()\n\n    async def listen(self):\n        await start_server(self.handler, port=PORT)\n        print(f\"INFO:     HTTP server running on on http://127.0.0.1:{PORT}\")\n\n\napp = App()\n\n\n@app.after_event\nasync def response(event: Event):\n    writer = event.data[\"writer\"]\n    req = event.data[\"request\"]\n    writer.write(f\"HTTP/1.1 200\\n\\n{event.result}\".encode())\n    writer.close()\n    print(\n        'INFO:     {}:{} - \"{} {} HTTP/{}\" 200 OK'.format(\n            *writer.get_extra_info(\"peername\"), req.method, req.url, req.http_version\n        )\n    )\n\n\n@app.on_event(\"GET:/\")\nasync def home():\n    return \"Welcome!\"\n\n\n@app.on_event(\"GET:/user/{username}\")\nasync def hello(username: Param):\n    return f\"Hello, {username}!\"\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener http_web:app\n$ INFO:     Tiny-listener HTTP server running on on localhost:8000\n</code></pre> <p>STEP 4, Try this on your browser: http://127.0.0.1:8000/user/Bob</p> <pre><code>...\n$ INFO:     127.0.0.1:52579 - \"GET /user/Bob HTTP/1.1\" 200 OK\n</code></pre>"},{"location":"usage-mqtt-client/","title":"MQTT Client","text":"<p>Info</p> <p>MQTT is a lightweight IOT protocol.</p> <p>asyncio_mqtt is an open source MQTT client and broker implementation with asyncio.</p> <p>Warning</p> <p>Most of time, MQTT client requires an available MQTT server.</p> <p>We use a publicly test MQTT server http://test.mosquitto.org/ here.</p> <p>Please don't publish anything sensitive, anybody could be listening.</p> <p>STEP 1, Install Tiny-listener and asyncio-mqtt:</p> <pre><code>$ pip install tiny-listener asyncio-mqtt\n</code></pre> <p>STEP 2, Create python file <code>mqtt_client.py</code>:</p> <pre><code>import asyncio\nimport random\n\nfrom asyncio_mqtt import Client\n\nfrom tiny_listener import Event, Listener, Param\n\nSERVER_HOST = \"test.mosquitto.org\"\n\n\nclass App(Listener):\n    async def listen(self):\n        async with Client(SERVER_HOST) as client:\n            await client.subscribe(\"/iot/home/+/temperature\")\n            self.trigger_event(\"/mock_iot_device\", data={\"client\": client})\n            async with client.messages() as messages:\n                # keep listening mqtt messages and trigger `handle_mqtt_msg` event\n                async for msg in messages:\n                    ctx = app.new_ctx()\n                    ctx.trigger_event(msg.topic.value, data={\"payload\": msg.payload})\n\n\napp = App()\n\n\n@app.on_event(\"/mock_iot_device\")\nasync def mock_iot_device(event: Event):\n\"\"\"Mock an IoT device that publishes temperature data\"\"\"\n    client: Client = event.data[\"client\"]\n    while True:\n        room = random.choices([\"living_room\", \"kitchen\", \"bedroom\", \"bathroom\", \"balcony\"])[0]\n        temperature = random.randint(10, 30)\n        await client.publish(f\"/iot/home/{room}/temperature\", temperature)\n        await asyncio.sleep(1)\n\n\n@app.on_event(\"/iot/home/{room}/temperature\")\nasync def handle_mqtt_msg(event: Event, room: Param):\n    temperature = event.data[\"payload\"].decode()\n    print(\"INFO: {:&lt;13} {} \u2103\".format(room, temperature))\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener mqtt_client:app\n</code></pre> <p>Output:</p> <pre><code>INFO: living_room   29 \u2103\nINFO: bedroom       29 \u2103\nINFO: bathroom      12 \u2103\n</code></pre>"},{"location":"usage-rabbitmq-consumer/","title":"RabbitMQ Consumer","text":"<p>Info</p> <p>RabbitMQ  is an open source message broker.</p> <p>aio-pika is a wrapper for the aiormq for asyncio and humans.</p> <p>Note</p> <p>This tutorial assumes RabbitMQ is installed and running on localhost on the standard port (5672).</p> <p>See: Downloading and Installing RabbitMQ</p> <p>STEP 1, Install Tiny-listener and aio-pika:</p> <pre><code>$ pip install tiny-listener aio-pika </code></pre> <p>STEP 2, Create python file <code>rabbitmq_consumer.py</code>:</p> <pre><code>import asyncio\n\nimport aio_pika\n\nfrom tiny_listener import Event, Listener, Param\n\n\nclass App(Listener):\n    def __init__(self):\n        super().__init__()\n        self.conn = None\n\n    async def listen(self):\n        self.conn = await aio_pika.connect_robust(\"amqp://127.0.0.1/\")\n        async with self.conn:\n            channel = await self.conn.channel()\n            queue = await channel.declare_queue(\"test_queue\", auto_delete=True)\n            app.trigger_event(\"/mock_producer\", data={\"channel\": channel})\n            async with queue.iterator() as msg_queue:\n                async for msg in msg_queue:\n                    async with msg.process():\n                        app.trigger_event(f\"/app/{msg.app_id}/consume\", data={\"data\": msg.body})\n\n\napp = App()\n\n\n@app.shutdown\nasync def shutdown():\n    await app.conn.close()\n\n\n@app.on_event(\"/mock_producer\")\nasync def produce(event: Event):\n    channel = event.data[\"channel\"]\n    for i in range(10):\n        await channel.default_exchange.publish(aio_pika.Message(body=bytes(i), app_id=str(i)), routing_key=\"test_queue\")\n        await asyncio.sleep(1)\n\n\n@app.on_event(\"/app/{app_id}/consume\")\nasync def consume(event: Event, app_id: Param):\n    data = event.data[\"data\"]\n    print(f\"INFO: App[{app_id}] consume: {data}\")\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener rabbitmq_consumer:app\n</code></pre> <p>Output:</p> <pre><code>INFO: App[0] consume: b''\nINFO: App[1] consume: b'\\x00'\nINFO: App[2] consume: b'\\x00\\x00'\nINFO: App[3] consume: b'\\x00\\x00\\x00'\n</code></pre>"},{"location":"usage-tcp-chat-bot/","title":"TCP Chat Bot","text":"<p>STEP 1, Install Tiny-listener:</p> <pre><code>$ pip install tiny-listener\n</code></pre> <p>STEP 2, Create python file <code>tcp_chat_bot.py</code>:</p> <pre><code>from asyncio import StreamReader, StreamWriter, start_server\n\nfrom tiny_listener import Depends, Event, Listener, EventNotFound\n\nADDRESS = (\"127.0.0.1\", 12345)\n\n\nclass App(Listener):\n    @staticmethod\n    async def tcp_handler(reader: StreamReader, writer: StreamWriter):\n        while True:\n            payload = await reader.readline()\n            if not payload:\n                break\n\n            try:\n                app.trigger_event(payload.strip().decode(), data={\"writer\": writer})\n            except EventNotFound:\n                writer.write(b\"Huh, go on.\\n\")\n\n    async def listen(self):\n        await start_server(self.tcp_handler, *ADDRESS)\n\n\napp = App()\n\n\nasync def get_writer(event: Event):\n    return event.data[\"writer\"]\n\n\n@app.on_event(\"{_}?\")\nasync def _(writer: StreamWriter = Depends(get_writer)):\n    writer.write(b\"I am confused, may be you should google it.\\n\")\n\n\n@app.on_event(\"{_}.\")\nasync def _(writer: StreamWriter = Depends(get_writer)):\n    writer.write(b\"Yes, it makes sense to me.\\n\")\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener tcp_chat_bot:app\n</code></pre> <p>STEP 4, Open a new terminal with:</p> <pre><code>$ nc -I 60 localhost 12345\n</code></pre> <p>STEP 5, Chat with your bot:</p> <pre><code>$ hello!\nHuh, go on.\n\n$ who are you?\nI am confused, may be you should google it.\n\n$ earth is flat.\nYes, it makes sense to me.\n</code></pre>"}]}