{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"A lightweight event framework"},{"location":"#introduction","title":"Introduction","text":"<p>Tiny-listener is a lightweight and flexible event framework.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install tiny-listener\n</code></pre>"},{"location":"#why-use-tiny-listener","title":"Why use tiny-listener","text":"<ul> <li>\u2714 Pure Python.</li> <li>\u2714 Lightning-fast, based on native coroutine.</li> <li>\u2714 100% test coverage.</li> </ul>"},{"location":"#example","title":"Example","text":"<p>Consider we want to write a program keep listening message received from somewhere (e.g. http request or message queue), when message arrived, we want to execute a series of operations in a certain order, e.g.</p> <ul> <li>step 1: save user data to database</li> <li>step 2: send email to user</li> </ul> <p>In the development process, we often encounter such problems:</p> <ul> <li>the source of step 1 and step 2 may be different</li> <li>step 2 may depend on the result of step 1, that is to say, step 2 may need to wait for step 1 to complete</li> <li>there are many messages, many events, and it is not easy to maintain</li> </ul> <p>Tiny-listener may help you solve these problems:</p> <p>Create a file <code>example.py</code> with:</p> <pre><code>from tiny_listener import Event, Listener, Param\n\n\nclass App(Listener):\n    async def listen(self):\n        ctx = self.new_ctx()\n        ctx.trigger_event(\"step 2: send email to alice@tl.com\")\n        ctx.trigger_event(\"step 1: save Alice's data to database\", data={\"age\": 35})\n\n\napp = App()\n\n\n@app.on_event(\"step 1: save {username}'s data to database\")\nasync def step_1(event: Event, username: Param):\n    age = event.data[\"age\"]\n    print(f\"Step-1: Save data done!, {username=}, {age=}\")\n\n\n@app.on_event(\"step 2: send email to {email}\")\nasync def step_2(event: Event, email: Param):\n    await event.wait_event_done(\"step_1\")\n    print(f\"Step-2: Send email done!, {email=}\")\n</code></pre> <p>Run it:</p> <pre><code>$ tiny-listener example:app\n&gt;&gt;&gt; Save data done!, username='Alice', age=35\n&gt;&gt;&gt; Send email done!, email='alice@tl.com'\n</code></pre>"},{"location":"#how-it-works","title":"How it works","text":"<ul> <li>Create your own Listener and listen something(e.g. port, queue ...):</li> </ul> <pre><code>from tiny_listener import Event, Listener, Param\n\n\nclass App(Listener):\n    async def listen(self):\n        ctx = self.new_ctx()\n        ctx.trigger_event(\"step 2: send email to alice@tl.com\")\n        ctx.trigger_event(\"step 1: save Alice's data to database\", data={\"age\": 35})\n</code></pre> <ul> <li>Add event handler to your listener:</li> </ul> <pre><code>app = App()\n\n\n@app.on_event(\"step 1: save {username}'s data to database\")\nasync def step_1(event: Event, username: Param):\n    age = event.data[\"age\"]\n    print(f\"Step-1: Save data done!, {username=}, {age=}\")\n\n\n@app.on_event(\"step 2: send email to {email}\")\nasync def step_2(event: Event, email: Param):\n    await event.wait_event_done(\"step_1\")\n    print(f\"Step-2: Send email done!, {email=}\")\n</code></pre> <ul> <li>Run listener with command:</li> </ul> <pre><code>$ tiny-listener example:app\n</code></pre> <ul> <li>Tiny-listener will dispatch every event automatically:</li> </ul> <pre><code>&gt;&gt;&gt; Step-1: Save data done!, username='Alice', age=35\n&gt;&gt;&gt; Step-2: Send email done!, email='alice@tl.com'\n</code></pre>"},{"location":"usage-http-web/","title":"Tiny \"Web Framework\"","text":"<p>Info</p> <p>h11 is a pure-Python HTTP/1.1 protocol library</p> <p>Note</p> <p>This tiny \"web framework\" is very simple, just intended to show how tiny-listener works.</p> <p>Don't try to use it to implement a web service from scratch, it's not a good idea.</p> <p>If you need a web framework for production, please use FastAPI, Django, or Flask</p> <p>STEP 1, Install tiny-listener and h11:</p> <pre><code>$ pip install tiny-listener h11 </code></pre> <p>STEP 2, Create python file <code>http_web.py</code>:</p> <pre><code>import asyncio\nfrom functools import partial\n\nimport h11\n\nfrom tiny_listener import Context, Event, EventNotFound, Listener, Param\n\nPORT = 8000\n\n\nclass HTTPContext(Context):\n    def response(self, status_code: int, data: bytes):\n        protocol: H11 = self.scope[\"protocol\"]\n        protocol.transport.write(protocol.conn.send(h11.Response(status_code=status_code, headers=[])))\n        protocol.transport.write(protocol.conn.send(h11.Data(data=data)))\n        protocol.transport.write(protocol.conn.send(h11.EndOfMessage()))\n        protocol.conn.start_next_cycle()\n        host, port, *_ = protocol.transport.get_extra_info(\"peername\")\n        print(f'INFO: {host}:{port} - \"{self.scope[\"method\"]} {self.scope[\"path\"]} HTTP/1.1\" {status_code}')\n\n    def throw_500(self):\n        self.response(500, b\"Internal Server Error\")\n\n\nclass H11(asyncio.Protocol):\n    def __init__(self, listener: Listener):\n        self.conn = h11.Connection(h11.SERVER)\n        self.transport: asyncio.Transport = None\n        self.listener = listener\n\n    def connection_made(self, transport):\n        self.transport = transport\n\n    def data_received(self, data: bytes):\n        self.conn.receive_data(data)\n        self.handle_event()\n\n    def handle_request(self, req: h11.Request):\n        path = req.target.decode()\n        method = req.method.decode()\n        ctx = self.listener.new_ctx(scope={\"protocol\": self, \"path\": path, \"method\": method})\n        try:\n            ctx.trigger_event(f\"{method}:{path}\")\n        except EventNotFound:\n            ctx.trigger_event(\"/\")\n\n    def handle_event(self):\n        request = None\n        while True:\n            event = self.conn.next_event()\n            event_type = type(event)\n            if event_type is h11.NEED_DATA:\n                break\n\n            if event_type is h11.Request:\n                request = event\n            elif event_type is h11.EndOfMessage:\n                self.handle_request(request)\n\n\nclass App(Listener[HTTPContext]):\n    async def listen(self) -&gt; None:\n        loop = asyncio.get_event_loop()\n        await loop.create_server(partial(H11, self), host=\"localhost\", port=PORT)\n        print(f\"INFO: HTTP server running on on http://127.0.0.1:{PORT}\")\n\n\napp = App()\napp.set_context_cls(HTTPContext)\n\n\n@app.on_event(\"GET:/user/{username}\")\nasync def hello(event: Event, username: Param):\n    event.ctx.response(200, f\"Hello, {username}!\".encode())\n\n\n@app.on_event(\"GET:/throw\")\nasync def throw(event: Event):\n    event.ctx.throw_500()\n\n\n@app.on_event()\nasync def home(event: Event):\n    event.ctx.response(200, b\"Welcome!\")\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener http_web:app\n$ INFO: Tiny-listener HTTP server running on on 127.0.0.1:8000\n</code></pre> <p>STEP 4, Try this on your browser: http://127.0.0.1:8000/user/bob</p> <pre><code>...\n$ INFO: ::1:52579 - \"GET /user/bob HTTP/1.1\" 200\n</code></pre>"},{"location":"usage-mqtt-client/","title":"MQTT Client","text":"<p>Info</p> <p>MQTT is a lightweight IOT protocol.</p> <p>asyncio_mqtt is an open source MQTT client and broker implementation with asyncio.</p> <p>Warning</p> <p>Most of time, MQTT client requires an available MQTT server.</p> <p>We use a publicly test MQTT server http://test.mosquitto.org/ here.</p> <p>Please don't publish anything sensitive, anybody could be listening.</p> <p>STEP 1, Install Tiny-listener and asyncio-mqtt:</p> <pre><code>$ pip install tiny-listener asyncio-mqtt\n</code></pre> <p>STEP 2, Create python file <code>mqtt_client.py</code>:</p> <pre><code>import asyncio\nimport random\n\nfrom asyncio_mqtt import Client\n\nfrom tiny_listener import Event, Listener, Param\n\nSERVER_HOST = \"test.mosquitto.org\"\n\n\nclass App(Listener):\n    async def listen(self):\n        async with Client(SERVER_HOST) as client:\n            await client.subscribe(\"/iot/home/+/temperature\")\n            self.trigger_event(\"/mock_iot_device\", data={\"client\": client})\n            async with client.messages() as messages:\n                # keep listening mqtt messages and trigger `handle_mqtt_msg` event\n                async for msg in messages:\n                    ctx = app.new_ctx()\n                    ctx.trigger_event(msg.topic.value, data={\"payload\": msg.payload})\n\n\napp = App()\n\n\n@app.on_event(\"/mock_iot_device\")\nasync def mock_iot_device(event: Event):\n\"\"\"Mock an IoT device that publishes temperature data\"\"\"\n    client: Client = event.data[\"client\"]\n    while True:\n        room = random.choices([\"living_room\", \"kitchen\", \"bedroom\", \"bathroom\", \"balcony\"])[0]\n        temperature = random.randint(10, 30)\n        await client.publish(f\"/iot/home/{room}/temperature\", temperature)\n        await asyncio.sleep(1)\n\n\n@app.on_event(\"/iot/home/{room}/temperature\")\nasync def handle_mqtt_msg(event: Event, room: Param):\n    temperature = event.data[\"payload\"].decode()\n    print(\"INFO: {:&lt;13} {} \u2103\".format(room, temperature))\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener mqtt_client:app\n</code></pre> <p>Output:</p> <pre><code>INFO: living_room   29 \u2103\nINFO: bedroom       29 \u2103\nINFO: bathroom      12 \u2103\n</code></pre>"},{"location":"usage-rabbitmq-consumer/","title":"RabbitMQ Consumer","text":"<p>Info</p> <p>RabbitMQ  is an open source message broker.</p> <p>aio-pika is a wrapper for the aiormq for asyncio and humans.</p> <p>Note</p> <p>This tutorial assumes RabbitMQ is installed and running on localhost on the standard port (5672).</p> <p>See: Downloading and Installing RabbitMQ</p> <p>STEP 1, Install Tiny-listener and aio-pika:</p> <pre><code>$ pip install tiny-listener aio-pika </code></pre> <p>STEP 2, Create python file <code>rabbitmq_consumer.py</code>:</p> <pre><code>import asyncio\n\nimport aio_pika\n\nfrom tiny_listener import Event, Listener, Param\n\n\nclass App(Listener):\n    def __init__(self):\n        super().__init__()\n        self.conn = None\n\n    async def listen(self):\n        self.conn = await aio_pika.connect_robust(\"amqp://127.0.0.1/\")\n        async with self.conn:\n            channel = await self.conn.channel()\n            queue = await channel.declare_queue(\"test_queue\", auto_delete=True)\n            app.trigger_event(\"/mock_producer\", data={\"channel\": channel})\n            async with queue.iterator() as msg_queue:\n                async for msg in msg_queue:\n                    async with msg.process():\n                        app.trigger_event(f\"/app/{msg.app_id}/consume\", data={\"data\": msg.body})\n\n\napp = App()\n\n\n@app.shutdown\nasync def shutdown():\n    await app.conn.close()\n\n\n@app.on_event(\"/mock_producer\")\nasync def produce(event: Event):\n    channel = event.data[\"channel\"]\n    for i in range(10):\n        await channel.default_exchange.publish(aio_pika.Message(body=bytes(i), app_id=str(i)), routing_key=\"test_queue\")\n        await asyncio.sleep(1)\n\n\n@app.on_event(\"/app/{app_id}/consume\")\nasync def consume(event: Event, app_id: Param):\n    data = event.data[\"data\"]\n    print(f\"INFO: App[{app_id}] consume: {data}\")\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener rabbitmq_consumer:app\n</code></pre> <p>Output:</p> <pre><code>INFO: App[0] consume: b''\nINFO: App[1] consume: b'\\x00'\nINFO: App[2] consume: b'\\x00\\x00'\nINFO: App[3] consume: b'\\x00\\x00\\x00'\n</code></pre>"},{"location":"usage-tcp-chat-bot/","title":"TCP Chat Bot","text":"<p>STEP 1, Install Tiny-listener:</p> <pre><code>$ pip install tiny-listener\n</code></pre> <p>STEP 2, Create python file <code>tcp_chat_bot.py</code>:</p> <pre><code>from asyncio import StreamReader, StreamWriter, start_server\n\nfrom tiny_listener import Depends, Event, Listener, EventNotFound\n\nADDRESS = (\"127.0.0.1\", 12345)\n\n\nclass App(Listener):\n    @staticmethod\n    async def tcp_handler(reader: StreamReader, writer: StreamWriter):\n        while True:\n            payload = await reader.readline()\n            if not payload:\n                break\n\n            try:\n                app.trigger_event(payload.strip().decode(), data={\"writer\": writer})\n            except EventNotFound:\n                writer.write(b\"Huh, go on.\\n\")\n\n    async def listen(self):\n        await start_server(self.tcp_handler, *ADDRESS)\n\n\napp = App()\n\n\nasync def get_writer(event: Event):\n    return event.data[\"writer\"]\n\n\n@app.on_event(\"{_}?\")\nasync def _(writer: StreamWriter = Depends(get_writer)):\n    writer.write(b\"I am confused, may be you should google it.\\n\")\n\n\n@app.on_event(\"{_}.\")\nasync def _(writer: StreamWriter = Depends(get_writer)):\n    writer.write(b\"Yes, it makes sense to me.\\n\")\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener tcp_chat_bot:app\n</code></pre> <p>STEP 4, Open a new terminal with:</p> <pre><code>$ nc -I 60 localhost 12345\n</code></pre> <p>STEP 5, Chat with your bot:</p> <pre><code>$ hello!\nHuh, go on.\n\n$ who are you?\nI am confused, may be you should google it.\n\n$ earth is flat.\nYes, it makes sense to me.\n</code></pre>"}]}