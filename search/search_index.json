{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"A lightweight event framework"},{"location":"#introduction","title":"Introduction","text":"<p>Tiny-listener is a lightweight and flexible event framework.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.8+</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>$ pip install tiny-listener\n</code></pre>"},{"location":"#why-use-tiny-listener","title":"Why use tiny-listener","text":"<ul> <li>\u2714 Pure Python.</li> <li>\u2714 Lightning-fast, based on native coroutine.</li> <li>\u2714 100% test coverage.</li> </ul>"},{"location":"#example","title":"Example","text":"<p>Create a file <code>example.py</code> with:</p> <pre><code>from tiny_listener import Listener, Event\n\nclass App(Listener):\n    async def listen(self):\n        ctx = self.new_ctx()\n        ctx.trigger_event(\"Say hi to Alice\")\n        ctx.trigger_event(\"Say hi to Bob\")\n        ctx.trigger_event(\"Say hi to Carol\")\n\n\napp = App()\n\n\n@app.on_event(\"Say hi to {name}\")\nasync def say_hi(event: Event):\n    print(\"Hi,\", event.params[\"name\"])\n</code></pre> <p>Run it:</p> <pre><code>$ tiny-listener example:app\n&gt;&gt;&gt; Hi, Alice\n&gt;&gt;&gt; Hi, Bob\n&gt;&gt;&gt; Hi, Carol\n</code></pre>"},{"location":"#how-it-works","title":"How it works","text":"<ul> <li>Create your own Listener and listen something(e.g. port, queue ...):</li> </ul> <pre><code>from tiny_listener import Listener, Event\n\nclass App(Listener):\n   async def listen(self):\n       ctx = self.new_ctx()\n       ctx.trigger_event(\"Say hi to Alice\")\n       ctx.trigger_event(\"Say hi to Bob\")\n       ctx.trigger_event(\"Say hi to Carol\")\n</code></pre> <ul> <li>Add event handler to your listener:</li> </ul> <pre><code>app = App()\n\n@app.on_event(\"Say hi to {name}\")\nasync def say_hi(event: Event):\n   print(\"Hi,\", event.params[\"name\"])\n</code></pre> <ul> <li>Run listener with command:</li> </ul> <pre><code>$ tiny-listener example:app\n</code></pre> <ul> <li>Tiny-listener will dispatch every event automatically:</li> </ul> <pre><code>&gt;&gt;&gt; Hi, Alice\n&gt;&gt;&gt; Hi, Bob\n&gt;&gt;&gt; Hi, Carol\n</code></pre>"},{"location":"usage-http-web/","title":"Tiny \"Web Framework\"","text":"<p>Info</p> <p>httptools is a fast HTTP parser lib.</p> <p>Note</p> <p>This tiny \"web framework\" is just intended to show how tiny-listener works.</p> <p>If your really need a web framework for production environment, using FastAPI / Django / Flask instead.</p> <p>STEP 1, Install Tiny-listener and httptools:</p> <pre><code>$ pip install tiny-listener httptools </code></pre> <p>STEP 2, Create python file <code>http_web.py</code>:</p> <pre><code>from asyncio import StreamReader, StreamWriter, start_server\n\nfrom httptools import HttpRequestParser\n\nfrom tiny_listener import Event, Listener, EventNotFound\n\nPORT = 8000\n\n\nclass Request:\n    def __init__(self, data: bytes):\n        self.url = \"\"\n        self.headers = {}\n        self.parser = HttpRequestParser(self)\n        self.parser.feed_data(data)\n\n    @property\n    def method(self) -&gt; str:\n        return self.parser.get_method().upper().decode()\n\n    @property\n    def http_version(self) -&gt; str:\n        return self.parser.get_http_version()\n\n    def on_url(self, url: bytes):\n        self.url = url.decode()\n\n    def on_header(self, name, value):\n        self.headers[name] = value\n\n\nclass App(Listener):\n    async def handler(self, reader: StreamReader, writer: StreamWriter):\n        data = await reader.readuntil(b\"\\r\\n\\r\\n\")\n        if data:\n            req = Request(data)\n            try:\n                self.trigger_event(\n                    f\"{req.method}:{req.url}\", data={\"writer\": writer, \"request\": req}\n                )\n            except EventNotFound:\n                writer.write(b\"HTTP/1.1 404\\n\\nPage Not Found\")\n                writer.close()\n\n    async def listen(self):\n        await start_server(self.handler, port=PORT)\n        print(f\"INFO:     HTTP server running on on http://127.0.0.1:{PORT}\")\n\n\napp = App()\n\n\n@app.after_event\nasync def response(event: Event):\n    writer = event.data[\"writer\"]\n    req = event.data[\"request\"]\n    writer.write(f\"HTTP/1.1 200\\n\\n{event.result}\".encode())\n    writer.close()\n    print(\n        'INFO:     {}:{} - \"{} {} HTTP/{}\" 200 OK'.format(\n            *writer.get_extra_info(\"peername\"), req.method, req.url, req.http_version\n        )\n    )\n\n\n@app.on_event(\"GET:/\")\nasync def home():\n    return \"Welcome!\"\n\n\n@app.on_event(\"GET:/user/{username}\")\nasync def hello(event: Event):\n    username = event.params[\"username\"]\n    return f\"Hello, {username}!\"\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener http_web:app\n$ INFO:     Tiny-listener HTTP server running on on localhost:8000\n</code></pre> <p>STEP 4, Try this on your browser: http://127.0.0.1:8000/user/Bob</p> <pre><code>...\n$ INFO:     127.0.0.1:52579 - \"GET /user/Bob HTTP/1.1\" 200 OK\n</code></pre>"},{"location":"usage-mqtt-client/","title":"MQTT Client","text":"<p>Info</p> <p>MQTT is a lightweight IOT protocol.</p> <p>amqtt is an open source MQTT client and broker implementation with asyncio.</p> <p>Warning</p> <p>Most of time, MQTT client requires an available MQTT server.</p> <p>We use a publicly test MQTT server http://test.mosquitto.org/ here.</p> <p>Please don't publish anything sensitive, anybody could be listening.</p> <p>STEP 1, Install Tiny-listener and amqtt:</p> <pre><code>$ pip install tiny-listener amqtt </code></pre> <p>STEP 2, Create python file <code>mqtt_client.py</code>:</p> <pre><code>from amqtt.client import MQTTClient\nfrom amqtt.mqtt.constants import QOS_0\nfrom amqtt.mqtt.publish import PublishPacket\n\nfrom tiny_listener import Event, Listener\n\nSERVER_ADDRESS = \"mqtt://test.mosquitto.org\"\n\n\nclass App(Listener):\n    async def listen(self):\n        client = MQTTClient()\n        await client.connect(SERVER_ADDRESS)\n        await client.subscribe(\n            [\n                (\"/test/home/+/temperature\", QOS_0),\n            ]\n        )\n        ctx = self.new_ctx(scope={\"client\": client})\n        ctx.trigger_event(\"/send\")\n        ctx.trigger_event(\"/recv\")\n\n\napp = App()\n\n\n@app.on_event(\"/send\")\nasync def _(event: Event):\n    client = event.ctx.scope[\"client\"]\n    await client.publish(\"/test/home/living_room/temperature\", b\"13\")\n    await client.publish(\"/test/home/kitchen/temperature\", b\"15\")\n\n\n@app.on_event(\"/recv\")\nasync def _(event: Event):\n    client = event.ctx.scope[\"client\"]\n    while True:\n        message = await client.deliver_message()\n        packet: PublishPacket = message.publish_packet\n        app.trigger_event(packet.variable_header.topic_name, data={\"payload\": packet.payload})\n\n\n@app.on_event(\"/test/home/{room}/temperature\")\nasync def _(event: Event):\n    room = event.params[\"room\"]\n    temperature = event.data[\"payload\"].data.decode()\n    print(\"INFO: {:&lt;13} {} \u2103\".format(room, temperature))\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener mqtt_client:app\n</code></pre> <p>Check the logs:</p> <pre><code>INFO: living_room   13 \u00b0C\nINFO: kitchen       15 \u00b0C\n</code></pre>"},{"location":"usage-rabbitmq-consumer/","title":"RabbitMQ Consumer","text":"<p>Info</p> <p>RabbitMQ  is an open source message broker.</p> <p>aio-pika is a wrapper for the aiormq for asyncio and humans.</p> <p>Note</p> <p>This tutorial assumes RabbitMQ is installed and running on localhost on the standard port (5672).</p> <p>See: Downloading and Installing RabbitMQ</p> <p>STEP 1, Install Tiny-listener and aio-pika:</p> <pre><code>$ pip install tiny-listener aio-pika </code></pre> <p>STEP 2, Create python file <code>rabbitmq_consumer.py</code>:</p> <pre><code>import aio_pika\n\nfrom tiny_listener import Event, Listener\n\n\nclass App(Listener):\n    async def listen(self):\n        connection = await aio_pika.connect_robust(\"amqp://127.0.0.1/\")\n        async with connection:\n            channel = await connection.channel()\n            queue = await channel.declare_queue(\"test_queue\", auto_delete=True)\n            app.trigger_event(\"/produce\", data={\"channel\": channel})\n\n            async with queue.iterator() as msg_queue:\n                async for msg in msg_queue:\n                    async with msg.process():\n                        app.trigger_event(f\"/app/{msg.app_id}/consume\", data={\"data\": msg.body})\n\n\napp = App()\n\n\n@app.on_event(\"/produce\")\nasync def _(event: Event):\n    channel = event.data[\"channel\"]\n    await channel.default_exchange.publish(\n        aio_pika.Message(body=b\"Hello, Alice!\", app_id=\"001\"), routing_key=\"test_queue\"\n    )\n    await channel.default_exchange.publish(\n        aio_pika.Message(body=b\"Hello, Bob!\", app_id=\"002\"), routing_key=\"test_queue\"\n    )\n\n\n@app.on_event(\"/app/{app_id}/consume\")\nasync def _(event: Event):\n    app_id = event.params[\"app_id\"]\n    data = event.data[\"data\"]\n    print(\"INFO: App[{}] consume: {}\".format(app_id, data))\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener rabbitmq_consumer:app\n</code></pre> <p>Check the logs:</p> <pre><code>INFO: App[001] consume: b'Hello, Alice!'\nINFO: App[002] consume: b'Hello, Bob!'\n</code></pre>"},{"location":"usage-tcp-chat-bot/","title":"TCP Chat Bot","text":"<p>STEP 1, Install Tiny-listener:</p> <pre><code>$ pip install tiny-listener\n</code></pre> <p>STEP 2, Create python file <code>tcp_chat_bot.py</code>:</p> <pre><code>from asyncio import StreamReader, StreamWriter, start_server\n\nfrom tiny_listener import Depends, Event, Listener, EventNotFound\n\nADDRESS = (\"127.0.0.1\", 12345)\n\n\nclass App(Listener):\n    @staticmethod\n    async def tcp_handler(reader: StreamReader, writer: StreamWriter):\n        while True:\n            payload = await reader.readline()\n            if not payload:\n                break\n\n            try:\n                app.trigger_event(payload.strip().decode(), data={\"writer\": writer})\n            except EventNotFound:\n                writer.write(b\"Huh, go on.\\n\")\n\n    async def listen(self):\n        await start_server(self.tcp_handler, *ADDRESS)\n\n\napp = App()\n\n\nasync def get_writer(event: Event):\n    return event.data[\"writer\"]\n\n\n@app.on_event(\"{_}?\")\nasync def _(writer: StreamWriter = Depends(get_writer)):\n    writer.write(b\"I am confused, may be you should google it.\\n\")\n\n\n@app.on_event(\"{_}.\")\nasync def _(writer: StreamWriter = Depends(get_writer)):\n    writer.write(b\"Yes, it makes sense to me.\\n\")\n</code></pre> <p>STEP 3, Run your app:</p> <pre><code>$ tiny-listener tcp_chat_bot:app\n</code></pre> <p>STEP 4, Open a new terminal with:</p> <pre><code>$ nc -I 60 localhost 12345\n</code></pre> <p>STEP 5, Chat with your bot:</p> <pre><code>$ hello!\nHuh, go on.\n\n$ who are you?\nI am confused, may be you should google it.\n\n$ earth is flat.\nYes, it makes sense to me.\n</code></pre>"}]}