{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A lightweight event framework Introduction \u00b6 Tiny-listener is a lightweight and flexible event framework. Requirements \u00b6 Python 3.6+ Installation \u00b6 $ pip install tiny-listener Why use tiny-listener \u00b6 \u2714 Pure Python. \u2714 Lighting-fast, based on native coroutine. \u2714 100% test coverage. Example \u00b6 Create a file example.py with: from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run it: $ tiny-listener example:app >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol How it works \u00b6 Create your own Listener and listen something(e.g. port, queue ...): from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) Add event handler to your listener: app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run listener with command: $ tiny-listener example:app Tiny-listener will dispatch every event automatically: >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol","title":"Introduction"},{"location":"#introduction","text":"Tiny-listener is a lightweight and flexible event framework.","title":"Introduction"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip install tiny-listener","title":"Installation"},{"location":"#why-use-tiny-listener","text":"\u2714 Pure Python. \u2714 Lighting-fast, based on native coroutine. \u2714 100% test coverage.","title":"Why use tiny-listener"},{"location":"#example","text":"Create a file example.py with: from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run it: $ tiny-listener example:app >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol","title":"Example"},{"location":"#how-it-works","text":"Create your own Listener and listen something(e.g. port, queue ...): from tiny_listener import Listener , Event class App ( Listener ): async def listen ( self ): self . fire ( \"Say hi to Alice\" ) self . fire ( \"Say hi to Bob\" ) self . fire ( \"Say hi to Carol\" ) Add event handler to your listener: app = App () @app . on_event ( \"Say hi to {name} \" ) async def say_hi ( event : Event ): print ( \"Hi,\" , event . params [ \"name\" ]) Run listener with command: $ tiny-listener example:app Tiny-listener will dispatch every event automatically: >>> Hi, Alice >>> Hi, Bob >>> Hi, Carol","title":"How it works"},{"location":"mqtt-listener/","text":"MQTT Listener \u00b6 Info MQTT is a lightweight IOT protocol. hbmqtt is an open source MQTT client and broker implementation with asyncio. Warning Most of time, MQTT client requires an available MQTT server. We use a publicly test MQTT server http://test.mosquitto.org/ here. Therefore, please don't publish anything sensitive, anybody could be listening. STEP 1, Install Tiny-listener and hbmqtt : $ pip install tiny-listener hbmqtt STEP 2, Create python file mqtt_client.py : import asyncio from datetime import datetime from random import randint from hbmqtt.client import MQTTClient from hbmqtt.mqtt.constants import QOS_0 from hbmqtt.mqtt.publish import PublishPacket from tiny_listener import Depends , Event , Listener SERVER_ADDRESS = \"mqtt://test.mosquitto.org\" class App ( Listener ): async def listen ( self ): self . fire ( \"/send\" ) self . fire ( \"/recv\" ) app = App () async def get_client () -> MQTTClient : client = MQTTClient () await client . connect ( SERVER_ADDRESS ) await client . subscribe ( [ ( \"/test/home/+/temperature\" , QOS_0 ), ] ) return client @app . on_event ( \"/test/home/ {room} /temperature\" ) async def _ ( event : Event ): payload = event . data [ \"payload\" ] print ( \"LOG [ {} ] | {:<13} | {} \" . format ( datetime . now (), event . params [ \"room\" ], payload . data . decode () ) ) @app . on_event ( \"/send\" ) async def _ ( client : MQTTClient = Depends ( get_client )): while True : await client . publish ( \"/test/home/living_room/temperature\" , f \" { randint ( 10 , 30 ) } \u2103\" . encode () ) await client . publish ( \"/test/home/kitchen/temperature\" , f \" { randint ( 10 , 30 ) } \u2103\" . encode () ) await asyncio . sleep ( 3 ) @app . on_event ( \"/recv\" ) async def _ ( client : MQTTClient = Depends ( get_client )): while True : message = await client . deliver_message () packet : PublishPacket = message . publish_packet app . fire ( packet . variable_header . topic_name , data = { \"payload\" : packet . payload }) STEP 3, Run your client: $ tiny-listener my_mqtt_client:app And check the log: LOG [2021-12-31 11:40:48.685079] | living_room | 13 \u00b0C LOG [2021-12-31 11:40:48.685349] | kitchen | 15 \u00b0C LOG [2021-12-31 11:40:51.693860] | living_room | 16 \u00b0C LOG [2021-12-31 11:40:51.694122] | kitchen | 14 \u00b0C ...","title":"MQTT listener"},{"location":"mqtt-listener/#mqtt-listener","text":"Info MQTT is a lightweight IOT protocol. hbmqtt is an open source MQTT client and broker implementation with asyncio. Warning Most of time, MQTT client requires an available MQTT server. We use a publicly test MQTT server http://test.mosquitto.org/ here. Therefore, please don't publish anything sensitive, anybody could be listening. STEP 1, Install Tiny-listener and hbmqtt : $ pip install tiny-listener hbmqtt STEP 2, Create python file mqtt_client.py : import asyncio from datetime import datetime from random import randint from hbmqtt.client import MQTTClient from hbmqtt.mqtt.constants import QOS_0 from hbmqtt.mqtt.publish import PublishPacket from tiny_listener import Depends , Event , Listener SERVER_ADDRESS = \"mqtt://test.mosquitto.org\" class App ( Listener ): async def listen ( self ): self . fire ( \"/send\" ) self . fire ( \"/recv\" ) app = App () async def get_client () -> MQTTClient : client = MQTTClient () await client . connect ( SERVER_ADDRESS ) await client . subscribe ( [ ( \"/test/home/+/temperature\" , QOS_0 ), ] ) return client @app . on_event ( \"/test/home/ {room} /temperature\" ) async def _ ( event : Event ): payload = event . data [ \"payload\" ] print ( \"LOG [ {} ] | {:<13} | {} \" . format ( datetime . now (), event . params [ \"room\" ], payload . data . decode () ) ) @app . on_event ( \"/send\" ) async def _ ( client : MQTTClient = Depends ( get_client )): while True : await client . publish ( \"/test/home/living_room/temperature\" , f \" { randint ( 10 , 30 ) } \u2103\" . encode () ) await client . publish ( \"/test/home/kitchen/temperature\" , f \" { randint ( 10 , 30 ) } \u2103\" . encode () ) await asyncio . sleep ( 3 ) @app . on_event ( \"/recv\" ) async def _ ( client : MQTTClient = Depends ( get_client )): while True : message = await client . deliver_message () packet : PublishPacket = message . publish_packet app . fire ( packet . variable_header . topic_name , data = { \"payload\" : packet . payload }) STEP 3, Run your client: $ tiny-listener my_mqtt_client:app And check the log: LOG [2021-12-31 11:40:48.685079] | living_room | 13 \u00b0C LOG [2021-12-31 11:40:48.685349] | kitchen | 15 \u00b0C LOG [2021-12-31 11:40:51.693860] | living_room | 16 \u00b0C LOG [2021-12-31 11:40:51.694122] | kitchen | 14 \u00b0C ...","title":"MQTT Listener"},{"location":"tcp-listener/","text":"TCP Listener \u00b6 TODO","title":"TCP listener"},{"location":"tcp-listener/#tcp-listener","text":"TODO","title":"TCP Listener"},{"location":"web-framework/","text":"Tiny \"Web Framework\" \u00b6 Info httptools is a fast HTTP parser lib. Note This tiny \"web framework\" is just intended to show how tiny-listener works. If your really need a web framework for production environment, using FastAPI / Django / Flask instead. STEP 1, Install Tiny-listener and httptools : $ pip install tiny-listener httptools STEP 2, Create python file my_web.py : from asyncio import StreamWriter , StreamReader , start_server from tiny_listener import Event , Listener , RouteNotFound from httptools import HttpRequestParser PORT = 8000 class Request : def __init__ ( self , data : bytes ): self . url = \"\" self . headers = {} self . parser = HttpRequestParser ( self ) self . parser . feed_data ( data ) @property def method ( self ) -> str : return self . parser . get_method () . upper () . decode () @property def http_version ( self ) -> str : return self . parser . get_http_version () def on_url ( self , url : bytes ): self . url = url . decode () def on_header ( self , name , value ): self . headers [ name ] = value class App ( Listener ): async def handler ( self , reader : StreamReader , writer : StreamWriter ) -> None : data = await reader . readuntil ( b \" \\r\\n\\r\\n \" ) if data : req = Request ( data ) try : self . fire ( f \" { req . method } : { req . url } \" , data = { \"writer\" : writer , \"request\" : req }) except RouteNotFound : writer . write ( b \"HTTP/1.1 404 \\n\\n Not Found\" ) writer . close () async def listen ( self ): await start_server ( self . handler , host = \"0.0.0.0\" , port = PORT ) print ( f \"INFO: Tiny-listener HTTP server running on on localhost: { PORT } \" ) app = App () @app . after_event async def response ( event : Event ): writer = event . data [ \"writer\" ] req = event . data [ \"request\" ] writer . write ( f \"HTTP/1.1 200 \\n\\n { event . result } \" . encode ()) writer . close () print ( 'INFO: {} : {} - \" {} {} HTTP/ {} \" 200 OK' . format ( * writer . get_extra_info ( \"peername\" ), req . method , req . url , req . http_version )) # api endpoint @app . on_event ( \"GET:/user/ {username} \" ) async def hello ( event : Event ): username = event . params [ 'username' ] return f \"Hello, { username } !\" STEP 3, Run your web: $ tiny-listener my_web:app $ INFO: Tiny-listener HTTP server running on on localhost:8000 STEP 4, Try this on your browser: http://127.0.0.1:8000/user/Bob ... $ INFO: 127 .0.0.1:52579 - \"GET /user/Bob HTTP/1.1\" 200 OK","title":"Usage: Tiny \"Web Framwork\""},{"location":"web-framework/#tiny-web-framework","text":"Info httptools is a fast HTTP parser lib. Note This tiny \"web framework\" is just intended to show how tiny-listener works. If your really need a web framework for production environment, using FastAPI / Django / Flask instead. STEP 1, Install Tiny-listener and httptools : $ pip install tiny-listener httptools STEP 2, Create python file my_web.py : from asyncio import StreamWriter , StreamReader , start_server from tiny_listener import Event , Listener , RouteNotFound from httptools import HttpRequestParser PORT = 8000 class Request : def __init__ ( self , data : bytes ): self . url = \"\" self . headers = {} self . parser = HttpRequestParser ( self ) self . parser . feed_data ( data ) @property def method ( self ) -> str : return self . parser . get_method () . upper () . decode () @property def http_version ( self ) -> str : return self . parser . get_http_version () def on_url ( self , url : bytes ): self . url = url . decode () def on_header ( self , name , value ): self . headers [ name ] = value class App ( Listener ): async def handler ( self , reader : StreamReader , writer : StreamWriter ) -> None : data = await reader . readuntil ( b \" \\r\\n\\r\\n \" ) if data : req = Request ( data ) try : self . fire ( f \" { req . method } : { req . url } \" , data = { \"writer\" : writer , \"request\" : req }) except RouteNotFound : writer . write ( b \"HTTP/1.1 404 \\n\\n Not Found\" ) writer . close () async def listen ( self ): await start_server ( self . handler , host = \"0.0.0.0\" , port = PORT ) print ( f \"INFO: Tiny-listener HTTP server running on on localhost: { PORT } \" ) app = App () @app . after_event async def response ( event : Event ): writer = event . data [ \"writer\" ] req = event . data [ \"request\" ] writer . write ( f \"HTTP/1.1 200 \\n\\n { event . result } \" . encode ()) writer . close () print ( 'INFO: {} : {} - \" {} {} HTTP/ {} \" 200 OK' . format ( * writer . get_extra_info ( \"peername\" ), req . method , req . url , req . http_version )) # api endpoint @app . on_event ( \"GET:/user/ {username} \" ) async def hello ( event : Event ): username = event . params [ 'username' ] return f \"Hello, { username } !\" STEP 3, Run your web: $ tiny-listener my_web:app $ INFO: Tiny-listener HTTP server running on on localhost:8000 STEP 4, Try this on your browser: http://127.0.0.1:8000/user/Bob ... $ INFO: 127 .0.0.1:52579 - \"GET /user/Bob HTTP/1.1\" 200 OK","title":"Tiny \"Web Framework\""}]}